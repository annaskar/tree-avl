#include "tree.h"
#include<iostream>
#include<cstring>
#include<string>
#include"foo.h"
using namespace std;

tree::tree() //ΚΕΝΟΣ ΚΑΤΑΣΤΕΥΑΣΤΗΣ
{
 root=NULL; //ΡΙΖΑ ΔΕΙΧΝΕΙ ΣΤΟ ΚΕΝΟ

    //ctor
}

void tree::postorder(foo*root) //ΕΜΦΑΝΙΣΗ ΔΕΔΟΜΕΝΩΝ ΜΕ POSTORDER ΤΑΞΙΝΟΜΗΣΗ
   {if(root==NULL) //ΕΛΕΝΧΟΣ ΡΙΖΑΣ ΑΝ ΕΙΝΑΙ ΚΕΝΗ ΑΠΛΑ ΤΕΛΕΙΩΝΕΙ Η ΣΥΝΑΡΤΗΣΗ ΚΑΙ ΔΕ ΕΠΙΣΤΡΕΦΕΙ ΤΙΠΟΤΑ
    {
        return;
    }

    postorder(root->left); //ΚΑΛΟΥΜΕ ΑΝΑΔΡΟΜΙΚΑ POSTORDER ΜΕ ΤΗΝ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΑΡΙΣΤΕΡΑ
    postorder(root->right);//ΚΑΛΟΥΜΕ ΑΝΑΔΡΟΜΙΚΑ POSTORDER ΜΕ ΤΗΝ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΔΕΞΙΑ
    cout<<root->p<<"PLH8OS :"<<root->pl<<endl; //ΕΜΦΑΝΙΖΟΥΜΕ ΤΗΝ ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ ΚΑΙ ΤΟ ΠΛΗΘΟΣ ΤΗΣ

}


void tree::preorder(foo*root) //ΤΑΞΙΝΟΜΙΣΗ PREORDER
{if(root==NULL) //AN Η ΡΙΖΑ ΔΕΙΧΝΕΙ ΣΤΟ ΚΕΝΟ
 {return;} //ΣΤΑΜΑΤΑΕΙ ΤΗΝ ΕΚΕΤΕΛΕΣΗ ΤΗΣ PREORDER
 cout<<root->p<<"PLH8OS :"<<root->pl<<endl;//ΕΜΦΑΝΙΣΗ ΤΗΣ ΛΕΞΗΣ ΤΗΣ ΡΙΖΑ ΚΑΙ ΤΟ ΠΛΗΘΟΣ ΤΗΣ
preorder(root->left); //ΚΑΛΕΙ ΑΝΑΔΡΟΜΙΚΑ ΤΗΝ PREORDER ΜΕ ΤΗ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΑΡΙΣΤΕΡΑ
preorder(root->right);//ΚΑΛΕΙ ΑΝΑΔΡΟΜΙΚΑ ΤΗΝ PREORDER ΜΕ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΔΕΞΙΑ
}



void tree::inorder(foo*root) //ΤΑΞΙΝΟΜΗΣΗ INORDER
{
    if(root==NULL) //ΑΝ ΤΟ ΡΟΟΤ ΔΕΙΧΝΕΙ ΣΕ ΚΕΝΟ
    {
        return; //ΤΕΡΜΑΤΙΖΕΙ Η INORDER
    }
inorder(root->left); //ΚΑΛΕΙ ΑΝΑΔΡΟΜΙΚΑ ΤΗΝ INORDER ΜΕ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΑΡΙΣΤΕΡΑ
cout<<root->p<<"PLH8OS :"<<root->pl<<endl; //ΕΜΦΑΝΙΣΗ ΤΗΝ ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ ΚΑΙ ΤΟ ΠΛΗΘΟΣ ΕΜΦΑΝΙΣΕΩΝ
inorder(root->right); //ΚΑΛΕΙ ΤΗΝ ΙΝORDER ΜΕ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΔΕΞΙΑ

}



void tree::insert_TREE(char*e) //ΣΥΝΑΡΤΗΣΗ ΕΙΣΑΓΩΓΗ ΣΤΟΙΧΕΙΟΥ ΣΤΟ ΔΕΝΤΡΟ
{
    foo*neo=new foo; //ΝΕΟΣ ΚΟΜΒΟΣ
    neo->pl+=1; // ΚΑΝΟΥΜΕ ΤΟ ΠΛΗΘΟΣ ΤΟΥ ΝΕΟΥ ΚΟΜΒΟΥ ΝΑ ΕΙΝΑΙ 1
    foo *parent;  //ΒΟΗΘΗΤΙΚΟΣ ΔΕΙΚΤΗΣ ΚΟΜΒΟΥ
    strcpy(neo->p,e); //ΑΝΤΙΓΡΑΦΗ ΤΗΣ ΤΡΕΧΟΝΤΟΣ ΛΕΞΗΣ ΣΤΟΝ ΠΙΝΑΚΑ ΤΟΥ ΚΟΜΒΟΥ ΝΕΟ
    if(root==NULL)//ΑΝ Η ΡΙΖΑ ΔΕΙΧΝΕΙ ΣΤΟ ΚΕΝΟ ΕΚΤΕΛΕΙΤΕ- ΜΟΝΟ ΓΙΑ ΤΗΝ ΠΡΩΤΗ ΛΕΞΗ ΠΟΥ ΔΙΝΕΤΕ-
    {
        root=neo; //ΑΝΤΙΓΡΑΦΕΤΕ ΣΤΗΝ ΡΙΖΑ ΤΑ ΣΤΟΙΧΕΙΑ ΤΟΥ ΝΕΟΥ ΚΟΜΒΟΥ
    }

    else  //ΑΝ Η ΡΙΖΑ ΔΕ ΔΕΙΧΝΕΙ ΣΤΟ ΚΕΝΟ ΤΟΤΕ
    {

     foo*par=root; //ΔΗΜΙΟΥΡΓΙΑ ΕΝΟΣ ΚΟΜΒΟΥ ΚΑΙ ΑΠΟΘΗΚΕΥΟΥΜΕ ΤΗΝ ΡΙΖΑ

    while(par!=NULL) //ΟΣΟ ΔΕΙΧΝΕΙ ΣΤΟ ΚΕΝΟ -Ο ΝΕΟΣ ΚΟΜΒΟΣ PAR -
         {
             parent=par; //ΒΑΖΩ ΤΑ ΠΕΡΙΕΧΟΥΜΕΝΑ ΤΟΥ ΚΟΜΒΟΥ PAR ΣΤΟΝ ΚΟΜΒΟ PARENT

         if(strcmp(e,par->p)>0) //AN H ΛΕΞΗ ΠΟΥ ΜΑΣ ΔΙΝΕΤΕ ΕΙΝΑΙ ΜΕΓΑΛΥΤΕΡΗ ΑΠΟ ΤΗΝ ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ
           {par=par->right; //ΚΑΝΟΥΜΕ ΤΟΝ ΚΟΜΒΟ PAR ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΔΕΞΙΑ ΤΟΥ
            }
         else
         {
            if(strcmp(e,par->p)==0) //ΑΝ Η ΛΕΞΗ ΠΟΥ ΜΑΣ ΔΙΝΕΤΕ ΕΙΝΑΙ ΙΣΗ ΜΕ ΤΗΝ ΛΕΞΗ ΠΟΥ ΠΕΡΙΕΧΕΤΤΕ ΣΤΟ PAR
           {
                par->pl+=1;//ΑΥΞΑΝΟΥΜΕ ΤΟ ΠΛΗΘΟΣ ΤΟΥ ΚΟΜΒΟΥ ΤΗΣ ΠΡΟΙΠΑΡΧΟΥΣΑΣ ΛΕΞΗΣ ΚΑΤΑ ΜΙΑ ΜΟΝΑΔΑ

                return ;//ΚΑΙ ΤΕΡΜΑΤΙΖΟΥΜΕ ΤΗΝ ΙΝΣΕΡΤ ΓΙΑ ΤΗΝ ΔΕΔΟΜΕΝΗ ΛΕΞΗ
            }

            else//AN H ΛΕΞΗ ΠΟΥ ΜΑΣ ΔΙΝΕΤΕ ΕΙΝΑΙ ΜΙΚΡΟΤΕΡΗ ΑΠΟ ΤΗΝ ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ
            {par=par->left;}//ΚΑΝΟΥΜΕ ΤΟΝ ΚΟΜΒΟ PAR ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΑΡΙΣΤΕΡΑ ΤΟΥ

            }
}
      if(strcmp(e,parent->p)>0) //ΑΝ Η  ΛΕΞΗ ΠΟΥ ΜΑΣ ΔΙΝΕΤΕ ΕΙΝΑΙ ΜΕΓΑΛΥΤΕΡΗ ΑΠΟ ΤΗΝ ΛΕΞΗ ΠΟΥ ΥΠΑΡΧΕΙ ΣΤΟΝ ΚΟΜΒΟ PARENT
             {parent->right=neo; //BAZΩ ΣΤΑ ΔΕΞΙΑ ΤΟΥ ΚΟΜΒΟΥ ΤΟΝ ΚΟΜΒΟ ΝΕΟ

             }
      else //ΑΝ Η  ΛΕΞΗ ΠΟΥ ΜΑΣ ΔΙΝΕΤΕ ΕΙΝΑΙ ΜΙΚΡΟΤΕΡΗ ΑΠΟ ΤΗΝ ΛΕΞΗ ΠΟΥ ΥΠΑΡΧΕΙ ΣΤΟΝ ΚΟΜΒΟ PARENT
        {parent->left=neo;//ΒΑΖΩ ΣΤΑ ΑΡΙΣΤΕΡΑ ΤΟΥ ΚΟΜΒΟΥ ΝΑ ΔΕΙΧΝΕΙ ΣΤΟ ΚΟΜΒΟ ΝΕΟ

        }
    }

    }

 bool tree::search_tree(char*a,foo*root) //ΣΥΝΑΡΤΗΣΗ ΠΟΥ ΕΠΙΣΤΡΕΦΕΙ TRUE ΑΝ ΥΠΑΡΧΕΙ Η ΛΕΞΗ Ή FALSE ΑΝ ΔΕ ΜΠΟΡΕΣΕ ΝΑ ΒΡΕΘΕΙ
{
    if(root==NULL)  //ΕΛΕΝΧΟΣ ΤΗΣ ΡΙΖΑ ΑΝ ΕΙΝΑΙ ΚΕΝΗ
    {
        return false;// ΑΝ ΕΙΝΑΙ ΚΕΝΗ ΕΠΙΣΤΡΕΦΕΙ FALSE
    }

   if(strcmp(root->p,a)==0) //ΑΝ ΤΟ ΣΤΕΧΕΙΟ ΕΙΝΑΙ ΙΣΟ ΜΕ ΤΟ ΣΤΟΙΧΕΙΟ ΤΗΣ ΡΙΖΑΣ
   {
    cout<<"FOUND TREE WORD :"<<a<<""<<"COYUNTER:"<<root->pl<<endl; //ΕΠΙΣΤΡΕΦΕΙ ΤΟ ΠΛΗΘΟΣ ΕΜΦΑΝΙΣΕΩΝ ΤΗΣ ΛΕΞΗΣ ΚΑΙ ΤΗΝ ΛΕΞΗ
    return true;  //ΚΑΙ TRUE ΓΙΑ ΝΑ ΤΕΡΜΑΤΙΣΕΙ Η SEARCH
   }
   if(strcmp(root->p,a)>0) //ΑΝ Η ΛΕΞΗ ΕΙΝΑΙ ΣΥΓΚΡΙΤΙΚΑ ΜΕ ΤΗΝ ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ ΜΙΚΡΟΤΕΡΗ
   {
       return search_tree(a,root->left); //ΚΑΛΕΙ ΑΝΑΔΡΟΜΙΚΑ ΤΗΝ SEARCHTREE ΜΕ ΤΗΝ ΛΕΞΗ ΚΑΙ ΜΕ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΑΡΙΣΤΕΡΑ
   }
   if(strcmp(root->p,a)<0) //ΑΝ Η ΛΕΞΗ ΕΙΝΑΙ ΣΥΓΚΡΙΤΙΚΑ ΜΕ ΤΗΝ ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ ΜΕΓΑΛΥΤΕΡΗ
   {
       return(search_tree(a,root->right));  //ΚΑΛΕΙ ΑΝΑΔΡΟΜΙΚΑ ΤΗΝ SEARCHTREE ΜΕ ΤΗΝ ΛΕΞΗ ΚΑΙ ΜΕ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΔΕΞΙΑ
   }

}



bool tree::delete_tree(char*a,foo*root) ///ΣΥΝΑΡΤΗΣΗ ΠΟΥ ΕΠΙΣΤΡΕΦΕΙ TRUE ΑΝ ΥΠΑΡΧΕΙ Η ΛΕΞΗ Ή FALSE ΑΝ ΔΕ ΜΠΟΡΕΣΕ ΝΑ ΔΙΑΓΡΑΦΘΕΙ ΚΑΤΑ 1
{
if(root==NULL) //ΑΝ Η ΡΙΖΑ ΔΕΙΧΝΕΙ ΣΕ ΚΕΝΟ
    return false; //ΕΠΙΣΤΡΕΦΕΙ Η ΔΙΑΓΡΑΦΗ FALSE ΚΑΙ ΔΕ ΔΙΑΓΡΑΦΕΤΕ ΤΟ ΣΤΟΙΧΕΙΟ
else
if(root->pl==0) //ΑΝ ΤΟ ΠΛΗΘΟΣ ΤΗΣ ΡΙΖΑΣ ΕΙΝΑΙ 0
{   cout<<"delete"<<a<<root->pl<<endl; //ΕΜΦΑΝΙΖΕΙ ΤΗΝ ΛΕΞΗ ΚΑΙ ΤΟ 0 ΣΑΝ ΠΛΗΘΟΣ ΛΕΞΕΩΝ
    return true;// ΕΠΙΣΤΡΕΦΕΙ TRUE
}
       if(strcmp(root->p,a)==0)//AN Η ΡΙΖΑ ΤΟΥ ΚΟΜΒΟΥ ΕΙΝΑΙ ΙΔΙΑ ΜΕ ΤΗΝ ΛΕΞΗ
   {
    root->pl-=1; //ΤΟΤΕ ΤΟ ΠΛΗΘΟΣ ΤΗΖΣ ΡΙΖΑΣ ΓΙΝΕΤΕ -1
    cout<<"delete"<<a<<root->pl<<endl; //ΕΜΦΑΝΙΣΗ ΤΗΣ ΛΕΞΗΣ ΚΑΙ ΤΟ ΠΛΗΘΟΣ ΤΗΣ ΛΕΞΗΣ
    return true; //ΚΑΙ ΕΠΙΣΤΡΕΦΕΙ TRUE
   }
   if(strcmp(root->p,a)>0) //ΑΝ Η ΛΕΞΗ ΤΗΣ ΡΙΖΑ ΕΙΝΑΙ ΜΕΓΑΛΥΤΕΡΗ ΑΠΟ ΤΗΝ ΛΕΞΗ
   {
       return delete_tree(a,root->left); //ΚΑΛΗ ΤΗΝ DELETETREE ΜΕ ΤΗΝ ΛΕΞΗ ΚΑΙ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΑΡΙΣΤΕΡΑ
   }
   if(strcmp(root->p,a)<0) //ΑΝ Η ΛΕΞΗ ΤΗΣ ΡΙΖΑΣ ΕΙΝΑΙ ΜΙΚΡΟΤΕΡΗ ΑΠΟ ΤΗΝ ΛΕΞΗ
   {
       return(delete_tree(a,root->right)); //ΚΑΛΕΙ ΑΝΑΔΡΟΜΙΚΑ ΤΗΝ DETELETREE ΜΕ ΤΗΝ ΛΕΞΗ ΚΑΙ ΤΗΝ ΡΙΖΑ ΝΑ ΔΕΙΧΝΕΙ ΣΤΑ ΔΕΞΙΑ
   }

}



tree::~tree()//ΚΑΤΑΣΤΡΟΦΕΑΣ
{
    //dtor
}

